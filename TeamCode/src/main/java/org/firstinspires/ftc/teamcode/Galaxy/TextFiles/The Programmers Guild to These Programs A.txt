Made by: Whitaker K. and Aayush V.

     Table of Contents:
 Line Number:   |   Topic:
 ==========================
    21          | CanOfPineapple
    32          | MacanumWheelRobot - v1.0
    184         | Constants         - v1.0












----{CanOfPineapple}-------------------------------------------------------------------------------
    The CanOfPineapple image capturing is a system that we made ourselves.
        The system has Five Simple Steps:

    1.) Create a CanOfPineapple
    2.) Get the image by calling getWhatIAmSeeing();
    3.) Create a PineappleStrainer Object passing it the picture
    4.) Call findColoredObject() passing it the needed methods
    5.) Get the pineappleChunks which can be used


----{MacanumWheelRobot}------------------------------------
    (11/17/2018 - Last Edit)

    MacanumWheelRobot, to say the last, is the main way of using most of our systems of classes that
    we have built. It contains an easy way of controlling all the motors, sensors, servos, and the
    robot itself... suggesting your wheels are mecanum wheels, of course.



    <Initializing>

    Before you initialze, make sure you import these two in your class somewhere:
    import static org.firstinspires.ftc.teamcode.Galaxy.Constants.*;
    import org.firstinspires.ftc.teamcode.Galaxy.Robot.MecanumWheelRobot;

    Then, to initialize the class, make sure you're in a function and do:
    MecanumWheelRobot someName = new MecanumWheelRobot(hardwareMap, MotorNameType);

    where someName is whatever name you want it to be, hardwareMap is the hardwareMap (you usually
    don't need to change the name of this), and MotorNameType is how you named your variables (look
    in Constants - MOTOR NAME CONFIGURATION to see some examples of this)

    The next sections will be split into four: DriveTrain (controlling the whole robot), Motors,
    Sensors, and Servos.




    <DriveTrain>

    This will mainly be a list of all the functions you can use and how to use them. There will be
    subcatagories to help you navigate.


    [Settings]

    First off is setBreakOrCoast(). This allows you to change the behavior when stopping the robot.
    Do you want to come to a full stop? Then you want to use DcMotor.ZeroPowerBehavior.BRAKE.
    Do you want to slide smoothly to a stop? Then you want DcMotor.ZeroPowerBehavior.FLOAT.
    An example of using this would be:
    someName.setBreakOrCoast(DcMotor.ZeroPowerBehavior.BRAKE);
    which would set the robot to fully stop.

    Next up is setMotorDirection(). Sometimes, the motors may be backwards from the intended
    direction due to how it was mounted on. This allows you to edit that, in the order of
    Left Front, Right Front, Right Back, and then Left Back.
    An example of using this would be:
    someName.setMotorDirection(REVERSE,FORWARDS,FORWARDS,REVERSE);


    [Driving]

    First is stopRobot(). This can mostly be explained via its name; the robot will stop moving
    its motors (and depending on setBreakOrCoast(), it will fully stop or slide a bit).
    An example of using this would be:
    someName.stopRobot().

    Next up are two of them, driveByTank() (tank controls) and driveByJoystick() (left stick is
    movement, right is turning). An example of using them is:
    someName.driveByTank(gamepad1, 0.8);
    which would use gamepad 1 for tank controls running at 0.8 speed. Speed can be anything between
    0 and 1.

    Finally, there's moveMotor(). This allows you to move every motor separately, making for easy
    testing.
    An example of using this would be:
    someName.moveMotor(RIGHT_FRONT, 0.8);
    which will move the motor with the tag RIGHT_FRONT (there's a tag for each wheel,
    in uppercase underscore format) at 0.8.


    [Autonomous Movement]

    There are only three functions you really need to know out of the four, moveDegrees(),
    spinRobot(), and turnGyro().

    moveDegrees() has 5-6 arguments, and it's honestly easier to explain them out.
    direction is what direction you want to go to. 0 is North (of the robot), 90 is East, you know
    the rest.
    degrees is how many degrees you want the wheels to turn. 360 would be one wheel rotation.
    spin allows you to do a curve. How much you want it to curve is up to experimentation.
    maxPower and minPower are well, the maximum and minimum you want the power to be. It goes from
    0-1.
    Finally, precision is how off you can be when turning. The closer to 1, the more precise.

    An example of using this would be:
    someName.moveDegrees(90, 720, 0.3, 1, 0.1, 5);
    which moves the robot east for 2 whole wheel rotations, spining the robot at 0.3,
    the power being from 0.1 - 1, and it being 5 degrees loose.

    spinRobot() is thankfully much easier to use. All you define is the power it should spin at
    (which means you do have to stop the robot).
    An example of this is:
    someName.spinRobot(0.5);

    Finally, there's turnGyro(). There are two arguments, toDegree and IMU.
    toDegree is the degree you want to spin to (0's north, 90's east, etc.),
    while the IMU is the control hub for the robot.
    To get the IMU, first make sure you have added it on (explained in the Motors section), then
    follow the example.
    An example of this is:
    someName.turnGyro(90, someName.getIMU("IMU"));
    someName.getIMU("IMU"); gets an IMU called "IMU", fyi.




    <Motors>
    Next up on the list is the Motors.

    First, to add a motor, do:
    someName.addAMotor(name, tag);
    name is well... the name of the motor defined in the robot config, and tag is for something
    like RIGHT_FRONT (wheel motor), LEFT_BACK, etc. (if you don't need a tag, use NO_TAG).

    To get a motor, there are two options, getMotorByName() and getMotorByTag().
    getMotorByName() gets a motor by it's name (someName.getMotorByName("arm");), and
    getMotorByTag() gets a motor by the tag you gave it, like
    someName.getMotorByTag(RIGHT_FRONT);




    <Sensors>
    You add sensors largely how you added motors, like:
    someName.addSensor(name, tag);
    where name is the name of the sensor and tag's something like COLOR_SENSOR or IMU.

    readSensor() is what gives you the values for the sensors.
    sensorName is the name of the sensor, and readingTag is something like COLOR_RED, TOUCH_VALUE,
    etc.
    An example of this is:
    someName.readSensor("gyro", GYRO_X);
    It returns the value as a float, by the way.

    For the IMU (the control hub), there are two functions for the Gyro built in it.
    ResetIMUGyro(name) resets the gyro of the IMU (replace name with the name of the IMU).
    ReadIMUGyro(name) returns a float array of the X, Y, and Z of the IMU gyro. Remember to replace
    name with the name of the IMU.




    <Servors>
    This is probably the easiest out of them all.
    You add servos largely how you added motors, like:
    someName.addServo(name);
    Notice how there's only the name to be added. You don't need a tag, unlike the other two.

    moveServo(name, toMoveTo) is also rather simple. name is the name of the servo, and toMoveTo
    is what degree you want the servo at.

----{Constants}-------------------------------------------------------------------------------------
    (11/17/2018 - Last Edit)

    Most of the time, you don't need to touch Constants. But in case you do, here are some things to
    note.

    Constants is basically a bunch of glorified variables, as in, there are basically variables
    usable for other programs that look cool. These variables are glorified via @InfDef, a thing
    built into Android Studio that allows a list of vars to be contained into one list for when you
    need them.

    If you need an example for how they are used, Sensors uses '@Constants.SensorTypes int
    sensorType' as part of the 'addSensor' function. It allows for a neat autocomplete of all of the
    vars in the SensorTypes list.

    If you look at the @IntDef section of Constants, you should get a good idea of how they are
    made into a list. Basically, something like
    @IntDef({LEFT_FRONT,RIGHT_FRONT, RIGHT_BACK, LEFT_BACK}) gets vars into a list,
    @Retention(RetentionPolicy.SOURCE) does... something important, and something like public
    @interface MotorTag{} allows for them to be used.

    If you ever want to use them, use import static org.firstinspires.ftc.teamcode.Constants.*;.