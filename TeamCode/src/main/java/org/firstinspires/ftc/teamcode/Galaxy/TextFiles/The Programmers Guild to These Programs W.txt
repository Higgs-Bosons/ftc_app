Made by: Whitaker K. and Aayush V.

----{CanOfPineapple}-------------------------------------------------------------------------------          (CanOfPineapple)
    (11/17/2018 - Last Edit)

    The CanOfPineapple image capturing is a system that we made ourselves.
        The system has Five Simple Steps:

    1.) Create a CanOfPineapple
    2.) Get the image by calling getWhatIAmSeeing();
    3.) Create a PineappleStrainer Object passing it the picture
    4.) Call findColoredObject() passing it the needed methods
    5.) Get the pineappleChunks which can be used

    The class CanOfPineapple is the object that controls the camera and the camera preview.  All of
    the objects are stored in the CanOfPineappleObjects class. CanOfPineapple then extends the
    CanOfPineappleObjects class, and thus has access to all of those variables. This allows the
    CanOfPineapple class to be more condense.




    -----{Setting up the CanOfPineapple}-------------------

    Step one: Add code to the base code.
    The first thing you need to do to set up the CanOfPineapple system is do some editing to the
    base code. Go to FtcRobotController/res/layout/activity_ftc_controller.xml (address is accurate
    for 4.3). Open up the .xml file and choose the option of text based display. You will then need
    to edit the file. Add this code:

          <TextView
              android:id="@+id/display"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:fontFamily="monospace"                                                                 (CanOfPineapple)
              android:text="Text"
              android:textColor="@android:color/black"
              android:textSize="2sp" />

          <TextureView
              android:id="@+id/CameraTexture"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content" />

    Underneath this code:

     <FrameLayout
            android:id="@+id/FrameLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_above="@+id/textGamepad1"
            android:layout_below="@+id/textOpMode">

      The final edited code should look like this:

       <FrameLayout
              android:id="@+id/FrameLayout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_above="@+id/textGamepad1"
              android:layout_below="@+id/textOpMode">

            <TextView
                android:id="@+id/display"
                android:layout_width="match_parent"                                                          (CanOfPineapple)
                android:layout_height="match_parent"
                android:fontFamily="monospace"
                android:text="Text"
                android:textColor="@android:color/black"
                android:textSize="2sp" />

            <TextureView
                android:id="@+id/CameraTexture"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />

     The FrameLayout object may look different, but there is only one FrameLayout. The two things
     that you added will be used by the CanOfPineapple class. You then will have to add some more
     code to this file:
     FtcRobotController/java/org/firstinspires/ftc/robotcontroller/internal/FtcRobotControllerActivity.java

     Open up this file and add this code to the end:

     // CanOfPineappleMethods
     public static TextureView CameraTexture;
     public static TextView displayText;

     public static TextureView getTextureView(){
         return CameraTexture;
     }
     public static void setTextDisplay(String text){
         displayText.setText(text);
         displayText.setScaleY(1);
         displayText.setScaleX(1);
        return;                                                                                              (CanOfPineapple)
     }
     // END

     Then you will have to add this code to the end of the onCreate() method. Add this to the end:

     // CanOfPineapple
     CameraTexture = (TextureView) findViewById(R.id.CameraTexture);
     CameraTexture.setScaleX(0);
     CameraTexture.setScaleY(0);

     displayText = (TextView) findViewById(R.id.display);
     displayText.setScaleX(0);
     displayText.setScaleY(0);
     displayText.setMovementMethod(new ScrollingMovementMethod());
     // END


     These methods and lines of code allow the CanOfPineapple class to change things on the screen.
     The FtcRobotControllerActivity.java is able to edit the screen by extending Activity. Because
     of how the stuff is set up by the app makers, none of the classes in TeamCode are able to
     access the Activity class. The next thing you have to do is add in the ImageCapturing package.
     Now take care of any errors that are due to changes in version of the FTC app. This setup works
     for Version 4.3.




     -----{Using the CanOfPineapple:}----------------------

     Set up in your code:
     The CanOfPineapple system is easy to use. The best way to learn how to use the system is to
     visualize the code system. The first thing you do is open the CanOfPineapple. Then you will             (CanOfPineapple)
     take can, and put it through the strainer. Then you have captured the chunks, and then use them.
     To use the system you need 3 objects. The CanOfPineapple, a PineappleStrainer, and PineappleChunks.
     At the start of the program, declare and initialize the  CanOfPineapple object. Once you
     initialize the object, the preview will start up. From then on, when ever you want to get the
     image (Bitmap), you just need to call CanOfPineapple.getBitmap(); This method will return the
     Bitmap the preview is displaying at that instance. You then can use the bitmap however you like.

     To use the PineappleStrainer object, you need to initialize and declare the object. When you do
     so you need to pass it some values. It need the value (in an int variable) of the contrast,
     precession, and the CanOfPineapple. The contrast is the sensitivity of the search. The higher
     contrast, the closer the pixel color will have to be to the original color to be counted. Thus
     the higher the contrast, the pickier the strainer. The precession is the how much of the picture
     it searches. At 100 (which is the highest) it checks every pixel. At 90, it checks 1 out of every
     10 pixels, at 80, it checks 1 out of every 20 pixels, and so on. a good starting point for you
     to start at would be about 85 precession and 80 contrast. You then can change these values to
     suit your needs. You also need to pass the CanOfPineapple object so the strainer can manipulate
     the preview.

     The next thing to do is to call the .findColoredObject() method on the
     PineappleStrainer object. You need to pass three objects to this method. The bitmap, the color
     you are looking for and the size of the object from 15cm. The bitmap is what will be search, and
     the color is the color that the object is and what will be searched for. The size variable is for
     basic and not so accurate distance readings. This method returns a PineappleChunks object,
     which holds all of the information about the objects found. It holds:
     1.) X value (0-100, where 0 is on the left and 100 on the right)
     2.) Y value (0-100, where 0 is up, and 100 is down)
     3.) Z value which is a distance from camera approximation (Not very accurate)
     4.) Width of the object
     5.) Height of the object
     6.) Size of the object (in pixels checked)                                                              (CanOfPineapple)
     7.) Reliability of the object.

     The size is how many pixels are in the object that was found. If the image looked like this:

         [][]
         [][][]
       [][][][][]
         [][][][][]  <- The size would be 17.
             [][]

     Here is an example program that can detect yellow cubes: (There are also some imports)


     @Autonomous(name = "Camera Tester", group = "Tester")
     public class CameraTester extends LinearOpMode {
         public void runOpMode(){
             CanOfPineapple thePineappleCan = new CanOfPineapple();
             waitForStart();
             Bitmap picture = thePineappleCan.getBitmap();
             PineappleStrainer pineappleStrainer = new PineappleStrainer( 80, 80, thePineappleCan);
             pineappleStrainer.findColoredObject(picture, Color.rgb(250,200, 0), 130);
             while (opModeIsActive()) {}
             thePineappleCan.closeCanOfPineapple();
         }
     }




     -----{How it works}-----------------------------------

     This part in unnecessary for those of you who just want to use the system, but I put it in so           (CanOfPineapple)
     you can make changes, fix problems, and update the code to make it more powerful.

     The CanOfPineapple object initializes a camera, and to be honest, I don't really know how that
     works, but it does. It displays a camera preview into a TextureView object. instead for actually
     taking a picture with the camera, all that it does it get the Bitmap the TextureView is displaying.
     This way is a LOT faster, but it gets a lower quality image, but that is fine, because we \
     reduce the quality more for speed later.

     The PineappleStrainer is a little bit more complex. I have previously made a greenscreen picture
     editor in Eclipse using Java. The formulas are very simualr. Here are the steps it takes:

     1.) It finds the color of a pixel on the screen that is the closest to the inputted color.
         For this set the program goes through the picture and compares the color a pixel with the
         inputted color to find. If the color is closer, it saves that color as the closest color
         then moves onto the next color until it has checked every pixel.

     2.) It checks if the closest color is close enough.
         If it didn't do this step, if it found no cube, it would compare the wrong colors later,
         leading to it finding the "correct" color, which could be a totally different color. If the
         closest color is not close enough, is exits the program and returns "No Cubes".

     3.) It creates an array of the found color.
         In this step the robot uses the closest


















