Made by: Whitaker K. and Aayush V.

        Version 4, 569 Lines

     Table of Contents:
 Line Number:   |   Topic:
 ==========================
    23          | CanOfPineapple ---- v2.0
    358         | MecanumWheelRobot - v1.1
    548         | Constants --------- v1.0.1


 Things in (),             friendly reminders of what section you are in
 Thing surrounded by ==,   Notes a new topic








----{CanOfPineapple}--------------------------------------------------------------------------------    =CanOfPineapple - Intro=
    (11/24/2018 - Last Edit) Accurate in these versions: 4.3

    Topic                 |  Line #
    -------------------------
    Setup                 |   #52
    Usage                 |   #152
     -findColoredObject   |   #169
     -findShadedObject    |   #218
    How it works          |   #259
    Two Search Methods    |   #312

    The CanOfPineapple image capturing is a system that we made ourselves.
        The system has Five Simple Steps:

    1.) Create a CanOfPineapple
    2.) Get the image by calling getWhatIAmSeeing();
    3.) Create a PineappleStrainer Object passing it the picture
    4.) Call findColoredObject() passing it the needed methods
    5.) Get the pineappleChunks which can be used

    The class CanOfPineapple is the object that controls the camera and the camera preview.  All of
    the objects are stored in the CanOfPineappleObjects class. CanOfPineapple then extends the
    CanOfPineappleObjects class, and thus has access to all of those variables. This allows the
    CanOfPineapple class to be more condense.




    -----{Setting up the CanOfPineapple}-------------------                                             =CanOfPineapple - Setting up the CanOfPineapple=

    Step one: Add code to the base code.
    The first thing you need to do to set up the CanOfPineapple system is do some editing to the
    base code. Go to FtcRobotController/res/layout/activity_ftc_controller.xml (address is accurate
    for 4.3). Open up the .xml file and choose the option of text based display. You will then need
    to edit the file. Add this code:

          <TextView
              android:id="@+id/display"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:fontFamily="monospace"                                                            (CanOfPineapple - Setting up the CanOfPineapple)
              android:text="Text"
              android:textColor="@android:color/black"
              android:textSize="2sp" />

          <TextureView
              android:id="@+id/CameraTexture"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content" />

    Underneath this code:

     <FrameLayout
            android:id="@+id/FrameLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_above="@+id/textGamepad1"
            android:layout_below="@+id/textOpMode">

      The final edited code should look like this:

       <FrameLayout
              android:id="@+id/FrameLayout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_above="@+id/textGamepad1"
              android:layout_below="@+id/textOpMode">

            <TextView
                android:id="@+id/display"
                android:layout_width="match_parent"                                                     (CanOfPineapple - Setting up the CanOfPineapple)
                android:layout_height="match_parent"
                android:fontFamily="monospace"
                android:text="Text"
                android:textColor="@android:color/black"
                android:textSize="2sp" />

            <TextureView
                android:id="@+id/CameraTexture"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />

     The FrameLayout object may look different, but there is only one FrameLayout. The two things
     that you added will be used by the CanOfPineapple class. You then will have to add some more
     code to this file:
     FtcRobotController/java/org/firstinspires/ftc/robotcontroller/internal/FtcRobotControllerActivity.java

     Open up this file and add this code to the end:

     // CanOfPineappleMethods
     public static TextureView CameraTexture;
     public static TextView displayText;

     public static TextureView getTextureView(){
         return CameraTexture;
     }
     public static void setTextDisplay(String text){
         displayText.setText(text);
         displayText.setScaleY(1);
         displayText.setScaleX(1);
        return;                                                                                         CanOfPineapple - Setting up the CanOfPineapple)
     }
     // END

     Then you will have to add this code to the end of the onCreate() method. Add this to the end:

     // CanOfPineapple
     CameraTexture = (TextureView) findViewById(R.id.CameraTexture);
     CameraTexture.setScaleX(0);
     CameraTexture.setScaleY(0);

     displayText = (TextView) findViewById(R.id.display);
     displayText.setScaleX(0);
     displayText.setScaleY(0);
     displayText.setMovementMethod(new ScrollingMovementMethod());
     // END


     These methods and lines of code allow the CanOfPineapple class to change things on the screen.
     The FtcRobotControllerActivity.java is able to edit the screen by extending Activity. Because
     of how the stuff is set up by the app makers, none of the classes in TeamCode are able to
     access the Activity class. The next thing you have to do is add in the ImageCapturing package.
     Now take care of any errors that are due to changes in version of the FTC app. This setup works
     for Version 4.3.




     -----{Using the CanOfPineapple:}----------------------                                             =CanOfPineapple - Using the CanOfPineapple=

     Set up in your code:
     The CanOfPineapple system is easy to use. The best way to learn how to use the system is to
     visualize the code system. The first thing you do is open the CanOfPineapple. Then you will        (CanOfPineapple - Using the CanOfPineapple)
     take can, and put it through the strainer. Then you have captured the chunks, and then use them.
     To use the system you need 3 objects. The CanOfPineapple, a PineappleStrainer, and PineappleChunks.
     At the start of the program, declare and initialize the  CanOfPineapple object. Once you
     initialize the object, the preview will start up. From then on, when ever you want to get the
     image (Bitmap), you just need to call CanOfPineapple.getBitmap(); This method will return the
     Bitmap the preview is displaying at that instance. You then can use the bitmap however you like.

     To use the PineappleStrainer object, you need to initialize and declare the object. When you do
     so you need to pass it one values. You need to pass the CanOfPineapple object so the
     strainer can manipulate the preview.


     --{Using .findColoredObject}----------------

     The next thing to do is to call the .findColoredObject() method on the
     PineappleStrainer object. You need to pass five objects to this method. The contrast, the
     precession, the bitmap, the color you are looking for and the size of the object from 15cm.
     The contrast is the sensitivity of the search. The higher contrast, the closer the pixel color
     will have to be to the original color to be counted. Thus the higher the contrast, the pickier
     the strainer. The precession is the how much of the picture it searches. At 100 (which is the
     highest) it checks every pixel. At 90, it checks 1 out of every 10 pixels, at 80, it checks 1
     out of every 20 pixels, and so on. a good starting point for you to start at would be about 85
     precession and 80 contrast. You then can change these values to suit your needs. The bitmap is
     what will be search, and the color is the color that the object is and what will be  searched
     for. The size variable is for basic and not so accurate distance readings. This method returns
     a PineappleChunks object, which holds all of the information about the objects found. It holds:

     1.) X value (0-100, where 0 is on the left and 100 on the right)
     2.) Y value (0-100, where 0 is up, and 100 is down)
     3.) Z value which is a distance from camera approximation (Not very accurate)
     4.) Width of the object
     5.) Height of the object
     6.) Size of the object (in pixels checked)                                                         (CanOfPineapple - Using the CanOfPineapple)
     7.) Reliability of the object.

     The size is how many pixels are in the object that was found. If the image looked like this:

         [][]
         [][][]
       [][][][][]
         [][][][][]  <- The size would be 17.
             [][]

     Here is an example program that can detect yellow cubes: (There are alo some imports)


     @Autonomous(name = "Camera Tester", group = "Tester")
     public class CameraTester extends LinearOpMode {
         public void runOpMode(){
             CanOfPineapple thePineappleCan = new CanOfPineapple();
             waitForStart();
             Bitmap picture = thePineappleCan.getBitmap();
             PineappleStrainer pineappleStrainer = new PineappleStrainer(thePineappleCan);
             pineappleStrainer.findColoredObject(80, 80, picture, Color.rgb(250, 200, 0), 130);
             while (opModeIsActive()) {}
             thePineappleCan.closeCanOfPineapple();
         }
     }                                                                                                  (CanOfPineapple - Using the CanOfPineapple)



     --{Using .findShadedObject}-----------------

     The next thing to do is to call the .findShadedObject() method on the
     PineappleStrainer object. You need to pass five objects to this method. The contrast, the
     precession, the bitmap, the color you are looking for and the size of the object from 15cm.
     The contrast is the sensitivity of the search. The higher contrast, the closer the pixel color
     will have to be to the original color to be counted. Thus the higher the contrast, the pickier
     the strainer. The precession is the how much of the picture it searches. At 100 (which is the
     highest) it checks every pixel. At 90, it checks 1 out of every 10 pixels, at 80, it checks 1
     out of every 20 pixels, and so on. a good starting point for you to start at would be about 85
     precession and 80 contrast. You then can change these values to suit your needs. The bitmap is
     what will be search, and the color is the color that the object is and what will be  searched
     for. The size variable is for basic and not so accurate distance readings. This method returns
     a PineappleChunks object, which holds all of the information about the objects found. It holds:

     1.) X value (0-100, where 0 is on the left and 100 on the right)
     2.) Y value (0-100, where 0 is up, and 100 is down)
     3.) Z value which is a distance from camera approximation (Not very accurate)
     4.) Width of the object
     5.) Height of the object
     6.) Size of the object (in pixels checked)                                                         (CanOfPineapple - Using the CanOfPineapple)
     7.) Reliability of the object.


     Here is an example program that can detect yellow cubes: (There are alo some imports)


     @Autonomous(name = "Camera Tester", group = "Tester")
     public class CameraTester extends LinearOpMode {
         public void runOpMode(){
             CanOfPineapple thePineappleCan = new CanOfPineapple();
             waitForStart();
             Bitmap picture = thePineappleCan.getBitmap();
             PineappleStrainer pineappleStrainer = new PineappleStrainer(thePineappleCan);
             pineappleStrainer.findShadedObject(80, 80, picture, Color.rgb(250, 200, 0), 130);
             while (opModeIsActive()) {}
             thePineappleCan.closeCanOfPineapple();
         }
     }


     -----{How it works}-----------------------------------                                             =CanOfPineapple - How it works=

     This part in unnecessary for those of you who just want to use the system, but I put it in so      (CanOfPineapple - How it works)
     you can make changes, fix problems, and update the code to make it more powerful.

     The CanOfPineapple object initializes a camera, and to be honest, I don't really know how that
     works, but it does. It displays a camera preview into a TextureView object. instead for actually
     taking a picture with the camera, all that it does it get the Bitmap the TextureView is displaying.
     This way is a LOT faster, but it gets a lower quality image, but that is fine, because we \
     reduce the quality more for speed later.

     The PineappleStrainer is a little bit more complex. I have previously made a green screen picture
     editor in Eclipse using Java. The formulas are very similar. Here are the steps it takes:

     1.) It finds the color of a pixel on the screen that is the closest to the inputted color.
         For this set the program goes through the picture and compares the color a pixel with the
         inputted color to find. If the color is closer, it saves that color as the closest color
         then moves onto the next color until it has checked every pixel.

     2.) It checks if the closest color is close enough.
         If it didn't do this step, if it found no cube, it would compare the wrong colors later,
         leading to it finding the "correct" color, which could be a totally different color. If the
         closest color is not close enough, is exits the program and returns "No Cubes".

     3.) It creates an array of the found color.
         In this step the robot uses the closest color as the threshold. Then it compares the colors
         to that color, and if they are close enough, it changes there spot in a 2D boolean array to
         true. Each spot on the array is connected to a pixel The Bitmap is no longer used after
         this step.

     4.) Using the array, it looks for large chunks.
         This set is the most confusing. The robot checks every block in the 2D array. If it is 'true',
         then is checks if it has already looked there, thus keeping each chunk separate. Then it
         Checks it there are any more 'true' spots in that line. Each time is finds another 'true'
         it increments the size counter. Then it compares to see if that is the farthest left or
         right 'true' on that blob. Once it hits 3 empty spots, it then move down one line and repeats.
         After it moves down, it checks for any more 'true's. If there another 'true' down there, it    (CanOfPineapple - How it works)
         records that as the lowest. After it cannot find any more 'true's, it then add the blob as
         a PineappleChunk. It uses the left, right, up, and down values to get the width and height.
         It then uses the left, up and width and height values to find the X and Y values. After it
         goes through all the pixels, it moves on to step 5.

     5.) It sorts the Pineapple Chunks.
         The next step is to filter out a the to-small chunks. The robot find the average size for
         the chunks. It then removes all the chunks that are smaller than that size, thus removing
         any 1-3 pixel chunks. It then returns the Pineapple Chunks.

     You then can use the Pineapple Chunks to find out how many chunks were found, and there cordinates.
     The X and Y values a calculated to a scale of 0 - 100.




     -----{Differences Between the Two Searches}----------                                              =CanOfPineapple - Two Search Method=

     As you may have noticed, there are two different methods you can use to search the bitmap image.
     There is one BIG difference.

     The findColorObject() compares the direct color of the pixel and  compares the RGB values. It
     finds the total difference between each of the values (red, green and blue) and combines them
     into one total offTotal value. It then checks if that value is  greater than the required
     maximum offTotal value.

     The findShadedObject() compares the ratio of the RGB values (Red/Green, Blue/Red, Green/Red).
     It then finds the difference between the ratio of the color in question and the color to find.
     It then combines all the differences into one total offTotal value. It then checks if that value
     is  greater than the required maximum offTotal value.

     FindColorObject() is better for searching for an object is bright light. It is more accurate
     in telling the differences in the colors. FindShadedObject() is better for searching for objects
     in different amounts of light. Use which ever one you find is better for your environment.

     And that's all folks!                                                                              (CanOfPineapple - Two Search Method)


























----{MacanumWheelRobot}------------------------------------                                             =MacanumWheelRobot - Intro=
    (11/24/2018 - Last Edit) Accurate in these versions: 4.3

       Topic        |   Line #
    -----------------------------
     Initializing   | #378
     Drive Train    | #397
     Motors         | #476
     Sensors        | #501
     Servos         | #522




    MacanumWheelRobot, to say the last, is the main way of using most of our systems of classes that
    we have built. It contains an easy way of controlling all the motors, sensors, servos, and the
    robot itself... suggesting your wheels are mecanum wheels, of course.



    -----{Initializing}------------------------------------                                             =MacanumWheelRobot - Initializing=

    Before you initialze, make sure you import these two in your class somewhere:
    import static org.firstinspires.ftc.teamcode.Galaxy.Constants.*;
    import org.firstinspires.ftc.teamcode.Galaxy.Robot.MecanumWheelRobot;

    Then, to initialize the class, make sure you're in a function and do:
    MecanumWheelRobot someName = new MecanumWheelRobot(hardwareMap, MotorNameType);

    where someName is whatever name you want it to be, hardwareMap is the hardwareMap (you usually
    don't need to change the name of this), and MotorNameType is how you named your variables (look
    in Constants - MOTOR NAME CONFIGURATION to see some examples of this)

    The next sections will be split into four: DriveTrain (controlling the whole robot), Motors,
    Sensors, and Servos.




    -----{DriveTrain}--------------------------------------                                             =MacanumWheelRobot - DriveTrain=

    This will mainly be a list of all the functions you can use and how to use them. There will be
    subcategories to help you navigate.


    [Settings]

    First off is setBreakOrCoast(). This allows you to change the behavior when stopping the robot.
    Do you want to come to a full stop? Then you want to use DcMotor.ZeroPowerBehavior.BRAKE.
    Do you want to slide smoothly to a stop? Then you want DcMotor.ZeroPowerBehavior.FLOAT.
    An example of using this would be:
    someName.setBreakOrCoast(DcMotor.ZeroPowerBehavior.BRAKE);
    which would set the robot to fully stop.

    Next up is setMotorDirection(). Sometimes, the motors may be backwards from the intended
    direction due to how it was mounted on. This allows you to edit that, in the order of
    Left Front, Right Front, Right Back, and then Left Back.
    An example of using this would be:
    someName.setMotorDirection(REVERSE,FORWARDS,FORWARDS,REVERSE);


    [Driving]

    First is stopRobot(). This can mostly be explained via its name; the robot will stop moving
    its motors (and depending on setBreakOrCoast(), it will fully stop or slide a bit).
    An example of using this would be:
    someName.stopRobot().

    Next up are two of them, driveByTank() (tank controls) and driveByJoystick() (left stick is         (MacanumWheelRobot - DriveTrain)
    movement, right is turning). An example of using them is:
    someName.driveByTank(gamepad1, 0.8);
    which would use gamepad 1 for tank controls running at 0.8 speed. Speed can be anything between
    0 and 1.

    Finally, there's moveMotor(). This allows you to move every motor separately, making for easy
    testing.
    An example of using this would be:
    someName.moveMotor(RIGHT_FRONT, 0.8);
    which will move the motor with the tag RIGHT_FRONT (there's a tag for each wheel,
    in uppercase underscore format) at 0.8.


    [Autonomous Movement]

    There are only three functions you really need to know out of the four, moveDegrees(),
    spinRobot(), and turnGyro().

    moveDegrees() has 5-6 arguments, and it's honestly easier to explain them out.
    direction is what direction you want to go to. 0 is North (of the robot), 90 is East, you know
    the rest.
    degrees is how many degrees you want the wheels to turn. 360 would be one wheel rotation.
    spin allows you to do a curve. How much you want it to curve is up to experimentation.
    maxPower and minPower are well, the maximum and minimum you want the power to be. It goes from
    0-1.
    Finally, precision is how off you can be when turning. The closer to 1, the more precise.

    An example of using this would be:
    someName.moveDegrees(90, 720, 0.3, 1, 0.1, 5);
    which moves the robot east for 2 whole wheel rotations, spining the robot at 0.3,
    the power being from 0.1 - 1, and it being 5 degrees loose.
                                                                                                        (MacanumWheelRobot - DriveTrain)
    spinRobot() is thankfully much easier to use. All you define is the power it should spin at
    (which means you do have to stop the robot).
    An example of this is:
    someName.spinRobot(0.5);

    Finally, there's turnGyro(). There are two arguments, toDegree and IMU.
    toDegree is the degree you want to spin to (0's north, 90's east, etc.),
    while the IMU is the control hub for the robot.
    To get the IMU, first make sure you have added it on (explained in the Motors section), then
    follow the example.
    An example of this is:
    someName.turnGyro(90, someName.getIMU("IMU"));
    someName.getIMU("IMU"); gets an IMU called "IMU", fyi.




    -----{Motors}------------------------------------------                                             =MacanumWheelRobot - Motors=
    Next up on the list is the Motors.

    First, to add a motor, do:
    someName.addAMotor(name, tag);
    name is well... the name of the motor defined in the robot config, and tag is for something
    like RIGHT_FRONT (wheel motor), LEFT_BACK, etc. (if you don't need a tag, use NO_TAG).

    To get a motor, there are two options, getMotorByName() and getMotorByTag().
    getMotorByName() gets a motor by it's name (someName.getMotorByName("arm");), and
    getMotorByTag() gets a motor by the tag you gave it, like
    someName.getMotorByTag(RIGHT_FRONT);

    If you just want to move a motor, we have a shortcut for that.
    You can use:
    someName.moveMotor(name, power)
    where name is the name of the motor and power is how much power you want to give to the
    motor.
    To stop the motor after you're done with it, do:
    someName.stopMotor(name)
    where name is the name of the motor.




    -----{Sensors}-----------------------------------------                                             =MacanumWheelRobot - Sensors=
    You add sensors largely how you added motors, like:
    someName.addSensor(name, tag);
    where name is the name of the sensor and tag's something like COLOR_SENSOR or IMU.

    readSensor() is what gives you the values for the sensors.
    sensorName is the name of the sensor, and readingTag is something like COLOR_RED, TOUCH_VALUE,
    etc.
    An example of this is:
    someName.readSensor("gyro", GYRO_X);
    It returns the value as a float, by the way.

    For the IMU (the control hub), there are two functions for the Gyro built in it.
    ResetIMUGyro(name) resets the gyro of the IMU (replace name with the name of the IMU).
    ReadIMUGyro(name) returns a float array of the X, Y, and Z of the IMU gyro. Remember to replace
    name with the name of the IMU.





    -----{Servos}------------------------------------------                                             =MacanumWheelRobot - Servos=
    This is probably the easiest out of them all.
    You add servos largely how you added motors, like:
    someName.addServo(name);
    Notice how there's only the name to be added. You don't need a tag, unlike the other two.

    moveServo(name, toMoveTo) is also rather simple. name is the name of the servo, and toMoveTo
    is what degree you want the servo at.


















----{Constants}-------------------------------------------------------------------------------------    =Constants - Intro=
    (11/24/2018 - Last Edit) Accurate in these versions: 4.3

    Most of the time, you don't need to touch Constants. But in case you do, here are some things to
    note.

    Constants is basically a bunch of glorified variables, as in, there are basically variables
    usable for other programs that look cool. These variables are glorified via @InfDef, a thing
    built into Android Studio that allows a list of vars to be contained into one list for when you
    need them.

    If you need an example for how they are used, Sensors uses '@Constants.SensorTypes int
    sensorType' as part of the 'addSensor' function. It allows for a neat autocomplete of all of the
    vars in the SensorTypes list.

    If you look at the @IntDef section of Constants, you should get a good idea of how they are
    made into a list. Basically, something like
    @IntDef({LEFT_FRONT, RIGHT_FRONT, RIGHT_BACK, LEFT_BACK, NO_TAG}) gets vars into a list,
    @Retention(RetentionPolicy.SOURCE) does... something important, and something like public
    @interface MotorTag{} allows for them to be used.

    If you ever want to use them, use import static org.firstinspires.ftc.teamcode.Constants.*;.